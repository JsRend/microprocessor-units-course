/*
Драйвер ЖКИ модуля MT20S4A.
20 x 4 символов.
Графический контроллер КБ1013ВГ6(HD44780).
8ми (4х) разрядная шина данных.
*/

#include "mt20s4a.h"

void _delay_us(uint32_t ticks)
{
    for (int32_t i = 0; i < (uint32_t)ticks * 2; i++)
        ;
}

void _delay_ms(uint32_t ticks)
{
    _delay_us(ticks * 1000);
}

#define CYCLE_TIMEOUT	0x500	/*Максимальное количество чтений флага готовности.*/
/*Функция проверки флага занятости.*/
void ctrl_ready ()
{
	#ifdef READ_BF
	uint16_t i;
	uint8_t busy;

	RS_IR();                	/*Обращение к регистру данных.*/
	RW_SET();                	/*Подача сигнала чтения.*/
	for (i = 0; i < CYCLE_TIMEOUT; i++)
	{
		E_SET();              	/*Строб.*/
		NOP();              	/*Задержка выставления данных контроллером >120нс.*/
		busy = BF;
		E_CLR();              	/*Строб.*/
		NOP();              	/*Задержка между операциями чтения >250нс.*/
		NOP();
		E_SET();
		NOP();
		E_CLR();
		NOP();
		if (busy == 0) break; 	/*Проверки бита готовности.*/
	}
	#else
	_delay_us(40);//время выполнения всех команд кроме clear disp равно 40 мкс
	#endif
}

/*Функция записи команд в графический контроллер.
Записываемые данные определяются аргументом data.*/
void cmd_write (unsigned char data)
{
	ctrl_ready(); /*Проверка флага занятости.*/

	/*Запись  в регистр команд.*/
	RS_IR();		/*Выбор регистра команд.*/
	RW_CLR();		/*Подача сигнала записи.*/

	/*Старшая декада*/
	E_SET();		/*Строб.*/
	DATA &= 0xFF00;
	DATA |= 0x00FF & data;	/*Вывод в порт данных для записи.*/
	NOP();			/*Задержка >230нс(минимальная длительность строба).*/
	E_CLR();		/*Строб.*/
//	NOP();

//	/*Младшая декада*/
//	E_SET();		/*Строб.*/
//	DATA &= 0xFFF0;
//	DATA |= 0x000F & data;	/*Вывод в порт данных для записи.*/
//	NOP();			/*Задержка >230нс(минимальная длительность строба).*/
//	E_CLR();		/*Строб.*/
}

/*Функция первоначальной установки разрядности шины
без проверки бита готовности.*/
void init_write(unsigned char data)
{
	/*Запись  в регистр команд.*/
	RS_IR();		/*Выбор регистра команд.*/
	RW_CLR();		/*Подача сигнала записи.*/

	E_SET();		/*Строб.*/
	DATA &= 0xFF00;
	DATA |= 0x00FF & data;
	NOP();			/*Задержка >230нс(минимальная длительность строба).*/
	E_CLR();		/*Строб.*/
}

/*Функция записи данных в графический контроллер.
Записываемые данные определяются аргументом data.*/
void data_write (unsigned char data)
{
	ctrl_ready(); /*Проверка флага занятости.*/

	/*Запись  в регистр команд(данных).*/
	RS_DR();		/*Выбор регистра данных.*/
	RW_CLR();		/*Подача сигнала записи.*/

	/*Старшая декада*/
	E_SET();		/*Строб.*/
	DATA &= 0xFF00;
	DATA |= 0x00FF & data;	/*Вывод в порт данных для записи.*/
	NOP();			/*Задержка >230нс(минимальная длительность строба).*/
	E_CLR();		/*Строб.*/

//	NOP();
//	/*Младшая декада*/
//	E_SET();		/*Строб.*/
//	DATA &= 0xFFF0;
//	DATA |= 0x000F & data;	/*Вывод в порт данных для записи.*/
//	NOP();			/*Задержка >230нс(минимальная длительность строба).*/
//	E_CLR();		/*Строб.*/
}

/*Функция инициализации ЖКИ.*/
void init_disp()
{
	/*Исходное состояние портов*/
	//DDATA |= 0x0F;	/*Порт данных на вывод.*/
	E_CLR();			/*Исходное состояние сигнала строба.*/
    //DCONTROL |= (1 << E) | (1 << RW) | (1 << RS);	/*Линии управления на вывод.*/

	//начальная настройка модуля
	_delay_ms(40);/*Задержка после включения питания.*/
	init_write(0x30);	/*Запись разрядности шины, без проверки бита готовности.*/
	_delay_us(40);/*Задержка 40мкс.*/
	init_write(0x30);	/*Запись разрядности шины, без проверки бита готовности.*/
	_delay_us(40);/*Задержка 40мкс.*/
	init_write(0x30);	/*Запись разрядности шины, без проверки бита готовности.*/
	_delay_us(40);/*Задержка 40мкс.*/
	init_write(0x20);	/*Запись разрядности шины, без проверки бита готовности.*/
	_delay_us(40);/*Задержка 40мкс.*/

	//настройка индикатора
	/*Выбор ширины шины DL, числа линий  N, размера символа F и страницы знакогенератора P.*/
	cmd_write(0x20 | DL << 4 | N << 3 | F << 2 | P << 1);

	/*Сдвиг курсора или экрана SC, направление сдвиги RL.*/
	cmd_write(0x10 | SC << 3 | RL << 2);

	/*Выбор режима счетчика адреса ID,  режим сдвига экрана S.*/
	cmd_write(0x04 | ID << 1 | S);

	/*Включение дисплея и курсора.*/
	cmd_write(0x08 | D << 2 | C << 1 | B);

	clr_disp();
}

/*Функция выключения ЖК дисплея.*/
void disp_off()
{
	/*Запись в регистр команд:
	выключение дисплея.*/
	cmd_write(0x08 | C << 1 | B);
}

/*Функция включения ЖК дисплея.*/
//!Закомментирована за ненадобностью
void disp_on()
{
	/*Запись в регистр команд:
	включение дисплея.*/
	cmd_write(0x08 | 1 << 2 | C << 1 | B);
}

/*Функция установки позиции курсора.*/
static void set_pos(uint8_t pos, uint8_t line)
{
	uint8_t adr;

	/*Установка адреса 0x00 если номер позиции выходит за пределы экрана.*/
	if (pos >= LCD_WIDTH)
	{
		cmd_write(0x80);
		return;
	}

	switch (line)
	{
		case 0:
			adr = pos;
			break;
		case 1:
			adr = 0x40 + pos;
			break;
		case 2:
			adr = 0x14 + pos;
			break;
		case 3:
			adr = 0x54 + pos;
			break;
		default:
			adr = 0x00;
	}

	cmd_write(0x80 | adr);/*Установка адреса курсора.*/
}

/*Функция вывода на дисплей символа.*/
void put_char(uint8_t ch, uint8_t pos, uint8_t line)
{
	/*Установка позиции курсора.*/
	set_pos(pos, line);
	/*Запись кода символа в память дисплея по текущему адресу курсора.*/
	data_write(ch);
}

/*Функция вывода на дисплей строки символов с переносом строки.*/
void put_str(const char s[],uint8_t pos, uint8_t line)
{
	unsigned char i, pos_tmp, line_tmp;

	for (i = 0; s[i] != '\0'; i++)/*Вывод строки посимвольно до достижения кода конца строки.*/
	{
		pos_tmp = (i + pos) % (LCD_WIDTH);
		line_tmp = (i + pos) / (LCD_WIDTH);
		if ((pos_tmp == 0) && (line_tmp == 4))
			break;
		set_pos(pos_tmp, line_tmp);
		data_write(s[i]);
	}
}

/*Функция вывода строки символов на одной строке без переноса.
В пределах одной строки индикатора работает быстрее функции put_str()
за счет автоматического инкремента позиции курсора графическим контроллером.*/
void put_str_ln(const char s[], uint8_t pos, uint8_t line)
{
	uint8_t i;

	set_pos(pos, line);/*Установка позиции курсора.*/
	for(i = 0; (s[i] != '\0') && ((i + pos) < LCD_WIDTH); i++)/*Вывод до достичения конца строки.*/
	{
		data_write(s[i]);
	}
}

/*Функция зачисти символа.*/
void clr_char(uint8_t pos, uint8_t line)
{
	set_pos(pos, line);
	data_write(' ');
}

/*Функция зачистки строки символов.*/
void clr_str(uint8_t pos, uint8_t line, uint8_t length)
{
	uint8_t i;

	set_pos(pos, line);/*Установка позиции курсора.*/
	for(i = 0; (i < length) && ((i + pos) < LCD_WIDTH); i++)/*Вывод до достичения конца строки.*/
	{
		data_write(' ');
	}
}

/*Функция очистки дисплея.*/
void clr_disp()
{
	cmd_write(0x01);
	_delay_ms(2);//время исполнения команды 1.5 мс
}

/*Функция сброса счечика AC.*/
void returnhome()
{
	cmd_write(0x02);
}
